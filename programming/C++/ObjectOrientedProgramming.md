# 数据抽象

## 抽象数据类型
`类 (class)` 机制的主要目的是用来提供新的`抽象数据类型 (abstract data type)`.
这里的`抽象`体现在:
- 类的`用户`只需要了解并且只能够使用类的`接口 (interface)`:
  - 包括`公共方法成员`和`公共数据成员`的声明,
  - 有时还包括`非成员接口函数` (如二元运算符) 的声明;
  - 通常在`头文件 (.h)` 中以`源码`形式给出.
- 类的`设计者`负责提供类的`实现 (implementation)`:
  - 包括`私有方法成员`和`私有数据成员`,
  - 以及`成员方法和非成员接口函数的定义`;
  - 通常在`源文件 (.cpp)` 中以`源码`形式给出,
  - 也可以只提供编译生成的`目标文件` (包括`静态库`或`动态库`文件).

这样做的好处是:
- `用户代码`只依赖于`接口代码`, 而不依赖于`实现代码`:
  - 类的`设计者`不需要将算法细节暴露给类的`用户`, 有助于保护知识产权.
  - `用户代码`和`实现代码`可以同时独立地进行开发和测试.
  - `实现代码`发生变化时, 不需要重新`编译用户代码`, 而只需要重新`编译实现代码`, 并将新的目标文件`链接进用户程序`.
- 有助于减少不同类之间的依赖, 使得彼此的`实现代码`可以`独立变化`, 并且可以`缩短编译时间`.

## 访问控制
### 访问修饰符 (Access Specifiers)
一个类可以含有`零个或多个`访问修饰符, 每种访问修饰符出现的`次数和顺序不限`.
每个访问修饰符的`作用范围`始于自己, 终于下一个修饰符或类的末尾.

| 访问修饰符 | 从类的外部 | 从类的内部 |
| -------- | -------- | -------- |
| `public` | 可以直接访问 | 可以直接访问 |
| `private` | (除友元外) 无法直接访问 | 可以直接访问 |

### `class` 与 `struct` 的区别
二者的区别仅在于:

| 关键词  | 隐含的第 `0` 个访问修饰符 |
| ------ | ---------------------- |
| `struct` | `public` |
| `class` | `private` |

### 友元 (少用)
定义一个类时, 可以用 `friend` 将其他类或函数`声明`为它的`友元`, 从而允许这些友元访问其私有成员.
通常, 将`友元声明`集中放在类定义的头部或尾部.
`友元声明`不是`函数声明`, 必须在定义类之前, 声明这些将要被设为友元的函数.

友元机制破坏了类的封装, 因此要少用.

## 数据成员

## 函数成员
### 声明与定义
所有`成员函数`都必须在类的内部 (位于`头文件`中) 进行`声明`, 但其`定义`可以放在类的外部 (通常位于`源文件`中).

- `内联的`成员函数应当定义在`含有所属类定义的头文件`中.
  - 定义在类的`内部`的函数是 (隐式) 内联的.
  - 定义在类的`外部`的成员函数也可以是 (显式) 内联的: 只需要在函数的返回类型前面加上 `inline` 关键词.
- `非内联的`成员函数应当定义在`与含有所属类定义的头文件同名的源文件`中.

### `this` 指针
除`静态`成员函数外, 所有成员函数都是通过隐式指针 `this` 来访问调用它的那个对象的.
例如:
```cpp
SalesData total;
total.isbn()
```
相当于
```cpp
SalesData::isbn(&total)
```

### `const` 成员函数
默认情况下, `this` 为指向`非 const` 对象的指针, 这使得相应的成员函数无法被 `const` 对象调用.
如果要使 `this` 为指向 `const` 对象的指针: 只需要在函数形参列表后面紧跟 `const` 关键词.

## 静态 (`static`) 成员
静态成员由一个`类`的所有`对象`共享, 而不属于其中任何一个`对象`:
- 静态`数据`成员存储于所有`对象`的外部, 因此不计入`对象`的大小.
- 静态`函数`成员独立于所有`对象`, 因此形参列表中没有隐含 `this` 指针.

### 访问静态成员
在类的外部, 静态成员可以通过紧跟在`类名`后面的作用域运算符 `::` 来访问, 也可以 (像非静态成员一样) 通过对象或指向该对象的指针或引用来访问.
与非静态成员类似, 静态成员可以被所属类的成员函数直接访问, 而不需要借助于作用域运算符.

### 定义静态成员
关键词  `static` 仅用于在类的内部`声明`静态成员, 而不需要在类的外部`定义`静态成员时重复.

`静态数据成员`必须在类的`外部`进行`定义`和`初始化`.
每个`静态数据成员`都只能被定义一次, 这与每个`非内联成员函数`都只能被定义一次类似.
因此, `静态数据成员的定义`应当与所属类的`非内联成员函数的定义`放在同一个`源文件`中.

定义静态数据成员时, 可以访问该类的`私有`成员, 这与定义其他成员类似.

### 类内初始化静态数据成员
通常, 静态数据成员`不可以`在类的内部进行初始化, 但有两个例外:
- `可以`为静态 `const` 整型数据成员指定类内初始值.
- `必须`为静态 `constexpr` 数据成员指定类内初始值.

被指定的类内初始值必须是 `constexpr`, 这些在类内被初始化的静态数据成员本身也是 `constexpr`, 可以用于任何需要使用 `constexpr` 的地方.
例如:
```cpp
// account.h
class Account {
 public:
  // ...
 private:
  static constexpr int period = 30;  // period 是 constexpr
  double table[period];  // 数组长度必须是 constexpr
};
```
即使一个静态数据成员已经在类内被初始化, 通常也应在类外给出定义.
如果其初始值已经在类内给定, 则类外不得再给定初始值:
```cpp
// account.cpp
constexpr int Account::period;
```

### 不同于非静态成员的特殊用法
静态数据成员的类型可以是它自己所属的那个类:
```cpp
class Bar {
 private:
  static Bar mem1;  // 正确: 静态数据成员 可以是 不完整类型
  Bar *mem2;        // 正确: 指针成员 可以是 不完整类型
  Bar mem3;         // 错误: 非静态数据成员 必须是 完整类型
};
```
静态数据成员可以被用作默认实参:
```cpp
class Screen {
 public:
  Screen& clear(char = background);
 private:
  static const char background;
};
```

## 类型成员
一个类可以在其内部定义新的`类型`或`类型别名`作为自己的成员.
`类型成员`必须在使用前被定义, 因此通常将它们集中定义在类的头部.
`类型成员`与`数据成员`和`函数成员`遵循相同的访问控制规则:
```cpp
class Screen {
 public:
  typedef std::string::size_type Position;
 private:
  Position cursor = 0;
  Position height = 0, width = 0;
  std::string contents;
};
```
## 类作用域

## 非成员函数接口

## 构造函数 (Constructor)
构造函数是一种`以类名作为函数名`的特殊成员函数, 用于构造该类的对象.
在构造过程中, 需要修改数据成员的值, 因此构造函数不可以被声明为 `const`.

与一般的函数不同, 构造函数`没有返回类型`.

### 默认构造函数
`不接受实参`的构造函数称为`默认 (default)` 构造函数.
默认构造函数可以是`形参列表为空`的构造函数, 也可以是`所有形参都有默认实参值`的构造函数.

#### 合成的默认构造函数
如果没有`显式地`定义任何构造函数, 那么编译器会`隐式地`定义一个`合成的 (synthesized)` 默认构造函数.
C++11 允许程序员显式地使用编译器合成的版本, 只需要在定义时在 (空) 形参列表后紧跟 `= default;` 即可.

### 初始化列表
```cpp
class Point {
  double _x;
  double _y;
};
```
`初始化列表`位于 `:` 与 `{` 之间, 用于对数据成员进行`值初始化`:
```cpp
// 推荐: 在 初始化列表 中进行 值初始化
Point::Point(const double& x, const double& y) : _x(x), _y(y) { }
```
如果某个数据成员没有在`初始化列表`中被初始化, 则会被`默认初始化`, 然后才会被函数体内的赋值语句修改:
```
// 语义相同, 但 默认初始化 过程浪费了计算资源
Point::Point(const double& x, const double& y) {
  _x = x;
  _y = y;
}
```

如果某个成员的值在初始化之后无法被修改, 则必须在`初始化列表`中对其进行初始化:
- 该成员是 `const`
- 该成员是`引用`类型
- 该成员无法被`默认初始化` (即: 没有默认构造函数)

#### 成员构造的顺序
成员构造的顺序不是它们出现在`初始化列表`中的顺序, 而是它们出现在`类的定义`中的顺序.

#### 委托构造函数
一个构造函数只需要在`初始化列表`中`调用`另一个构造函数, 就可以将构造任务`委托`给另一个构造函数, :
```cpp
class Point {
 public:
  Point(const double& x, const double& y) : _x(x), _y(y) { }
  Point() : Point(0.0, 0.0) { }
 private:
  double _x;
  double _y;
};
```

### 显式 (`explicit`) 构造函数
默认情况下, 只需要传入`一个实参`的构造函数`隐式地`定义了一种由`形参类型`到该`类类型`的转换.
编译器只会进行一次隐式类型转换.

如果要禁止这种隐式类型转换, 只需要在构造函数的声明`前`, 用关键词 `explicit` 进行修饰.
例如:
```cpp
namespace std{
template <
  class T, 
  class Allocator = std::allocator<T>
> class vector {
 public:
  explicit vector(std::size_type count);  // 禁止用于隐式类型转换
  // ...
};
}
```

# 运算符重载

## 常用运算符

## 函数调用运算符

## 类型转换

# 拷贝控制

## 析构函数 (Destructor)
析构函数是一种`以 ~ 为前缀的类名作为函数名`的特殊成员函数, 用于析构 (销毁) 该类的对象.
析构函数`没有返回类型`, 并且`形参列表为空`.
```cpp
class Foo {
 public:
  ~Foo();  // destructor
  // ...
};
```

### 成员析构的顺序
一个对象被析构时, 先执行其所属类型的析构函数体中的语句, 再隐式地析构其 (非静态) 数据成员.
数据成员被析构的顺序与它们被构造的顺序`相反`, 即: 与它们在类的定义中出现的顺序相反.

### 合成的析构函数
如果析构函数没有被`显式地声明`, 那么编译器会`隐式地定义`一个默认的版本, 称为`合成的析构函数`.
C++11 允许程序员显式地使用编译器合成的版本, 只需要在定义时在 (空) 形参列表后紧跟 `= default;` 即可.

合成的析构函数, 只会`逐个析构`数据成员 --- 这意味着: 不会对`裸指针`成员调用 `delete`.

## 拷贝构造函数

## 拷贝运算符

## 移动构造函数

## 移动运算符

# 继承

## 基类

## 派生类

## 类型转换与继承

## 访问控制与继承

# 动态绑定

## 虚函数

## 抽象基类

## 容器与继承


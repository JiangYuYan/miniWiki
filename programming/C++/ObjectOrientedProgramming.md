# 数据抽象

## 抽象数据类型
`类 (class)` 机制的主要目的是用来提供新的`抽象数据类型 (abstract data type)`.
这里的`抽象`体现在:
- 类的`用户`只需要了解并且只能够使用类的`接口 (interface)`:
  - 包括`公共方法成员`和`公共数据成员`的声明,
  - 有时还包括`非成员接口函数` (如二元运算符) 的声明;
  - 通常在`头文件 (.h)` 中以`源码`形式给出.
- 类的`设计者`负责提供类的`实现 (implementation)`:
  - 包括`私有方法成员`和`私有数据成员`,
  - 以及`成员方法和非成员接口函数的定义`;
  - 通常在`源文件 (.cpp)` 中以`源码`形式给出,
  - 也可以只提供编译生成的`目标文件` (包括`静态库`或`动态库`文件).

这样做的好处是:
- `用户代码`只依赖于`接口代码`, 而不依赖于`实现代码`:
  - 类的`设计者`不需要将算法细节暴露给类的`用户`, 有助于保护知识产权.
  - `用户代码`和`实现代码`可以同时独立地进行开发和测试.
  - `实现代码`发生变化时, 不需要重新`编译用户代码`, 而只需要重新`编译实现代码`, 并将新的目标文件`链接进用户程序`.
- 有助于减少不同类之间的依赖, 使得彼此的`实现代码`可以`独立变化`, 并且可以`缩短编译时间`.

## 访问控制
### 访问修饰符 (Access Specifiers)
一个类可以含有`零个或多个`访问修饰符, 每种访问修饰符出现的`次数和顺序不限`.
每个访问修饰符的`作用范围`始于自己, 终于下一个修饰符或类的末尾.

| 访问修饰符 | 从类的外部 | 从类的内部 |
| -------- | -------- | -------- |
| `public` | 可以直接访问 | 可以直接访问 |
| `private` | (除友元外) 无法直接访问 | 可以直接访问 |

### `class` 与 `struct` 的区别
二者的区别仅在于:

| 关键词  | 隐含的第 `0` 个访问修饰符 |
| ------ | ---------------------- |
| `struct` | `public` |
| `class` | `private` |

### 友元 (少用)
定义一个类时, 可以用 `friend` 将其他类或函数`声明`为它的`友元`, 从而允许这些友元访问其私有成员.
通常, 将`友元声明`集中放在类定义的头部或尾部.
`友元声明`不是`函数声明`, 必须在定义类之前, 声明这些将要被设为友元的函数.

友元机制破坏了类的封装, 因此要少用.

## 数据成员

## 函数成员
### 声明与定义
所有`成员函数`都必须在类的内部 (位于`头文件`中) 进行`声明`, 但其`定义`可以放在类的外部 (通常位于`源文件`中).

- `内联的`成员函数应当定义在`含有所属类定义的头文件`中.
  - 定义在类的`内部`的函数是 (隐式) 内联的.
  - 定义在类的`外部`的成员函数也可以是 (显式) 内联的: 只需要在函数的返回类型前面加上 `inline` 关键词.
- `非内联的`成员函数应当定义在`与含有所属类定义的头文件同名的源文件`中.

### `this` 指针
除`静态`成员函数外, 所有成员函数都是通过隐式指针 `this` 来访问调用它的那个对象的.
例如:
```cpp
SalesData total;
total.isbn()
```
相当于
```cpp
SalesData::isbn(&total)
```

### `const` 成员函数
默认情况下, `this` 为指向`非 const` 对象的指针, 这使得相应的成员函数无法被 `const` 对象调用.
如果要使 `this` 为指向 `const` 对象的指针: 只需要在函数形参列表后面紧跟 `const` 关键词.

## 静态 (`static`) 成员

## 类型成员

## 类作用域

## 非成员函数接口

## 构造函数

# 运算符重载

## 常用运算符

## 函数调用运算符

## 类型转换

# 拷贝控制

## 析构函数

## 拷贝构造函数

## 拷贝运算符

## 移动构造函数

## 移动运算符

# 继承

## 基类

## 派生类

## 类型转换与继承

## 访问控制与继承

# 动态绑定

## 虚函数

## 抽象基类

## 容器与继承


# 数据抽象

## 抽象数据类型
`类 (class)` 机制的主要目的是用来提供新的`抽象数据类型 (abstract data type)`.
这里的`抽象`体现在:
- 类的`用户`只需要了解并且只能够使用类的`接口 (interface)`:
  - 包括`公共方法成员`和`公共数据成员`的声明,
  - 有时还包括`非成员接口函数` (如二元运算符) 的声明;
  - 通常在`头文件 (.h)` 中以`源码`形式给出.
- 类的`设计者`负责提供类的`实现 (implementation)`:
  - 包括`私有方法成员`和`私有数据成员`,
  - 以及`成员方法和非成员接口函数的定义`;
  - 通常在`源文件 (.cpp)` 中以`源码`形式给出,
  - 也可以只提供编译生成的`目标文件` (包括`静态库`或`动态库`文件).

这样做的好处是:
- `用户代码`只依赖于`接口代码`, 而不依赖于`实现代码`:
  - 类的`设计者`不需要将算法细节暴露给类的`用户`, 有助于保护知识产权.
  - `用户代码`和`实现代码`可以同时独立地进行开发和测试.
  - `实现代码`发生变化时, 不需要重新`编译用户代码`, 而只需要重新`编译实现代码`, 并将新的目标文件`链接进用户程序`.
- 有助于减少不同类之间的依赖, 使得彼此的`实现代码`可以`独立变化`, 并且可以`缩短编译时间`.

## 访问控制
### 访问修饰符 (Access Specifiers)
一个类可以含有`零个或多个`访问修饰符, 每种访问修饰符出现的`次数和顺序不限`.
每个访问修饰符的`作用范围`始于自己, 终于下一个修饰符或类的末尾.

| 访问修饰符 | 从类的外部 | 从类的内部 |
| -------- | -------- | -------- |
| `public` | 可以直接访问 | 可以直接访问 |
| `private` | (除友元外) 无法直接访问 | 可以直接访问 |

### `class` 与 `struct` 的区别
二者的区别仅在于:

| 关键词  | 隐含的第 `0` 个访问修饰符 |
| ------ | ---------------------- |
| `struct` | `public` |
| `class` | `private` |

### 友元 (少用)
定义一个类时, 可以用 `friend` 将其他类或函数`声明`为它的`友元`, 从而允许这些友元访问其私有成员.
通常, 将`友元声明`集中放在类定义的头部或尾部.
`友元声明`不是`函数声明`, 必须在定义类之前, 声明这些将要被设为友元的函数.

友元机制破坏了类的封装, 因此要少用.

## 数据成员

## 函数成员
### 声明与定义
所有`成员函数`都必须在类的内部 (位于`头文件`中) 进行`声明`, 但其`定义`可以放在类的外部 (通常位于`源文件`中).

- `内联的`成员函数应当定义在`含有所属类定义的头文件`中.
  - 定义在类的`内部`的函数是 (隐式) 内联的.
  - 定义在类的`外部`的成员函数也可以是 (显式) 内联的: 只需要在函数的返回类型前面加上 `inline` 关键词.
- `非内联的`成员函数应当定义在`与含有所属类定义的头文件同名的源文件`中.

### `this` 指针
除`静态`成员函数外, 所有成员函数都是通过隐式指针 `this` 来访问调用它的那个对象的.
例如:
```cpp
SalesData total;
total.isbn()
```
相当于
```cpp
SalesData::isbn(&total)
```

### `const` 成员函数
默认情况下, `this` 为指向`非 const` 对象的指针, 这使得相应的成员函数无法被 `const` 对象调用.
如果要使 `this` 为指向 `const` 对象的指针: 只需要在函数形参列表后面紧跟 `const` 关键词.

## 静态 (`static`) 成员
静态成员由一个`类`的所有`对象`共享, 而不属于其中任何一个`对象`:
- 静态`数据`成员存储于所有`对象`的外部, 因此不计入`对象`的大小.
- 静态`函数`成员独立于所有`对象`, 因此形参列表中没有隐含 `this` 指针.

### 访问静态成员
在类的外部, 静态成员可以通过紧跟在`类名`后面的作用域运算符 `::` 来访问, 也可以 (像非静态成员一样) 通过对象或指向该对象的指针或引用来访问.
与非静态成员类似, 静态成员可以被所属类的成员函数直接访问, 而不需要借助于作用域运算符.

### 定义静态成员
关键词  `static` 仅用于在类的内部`声明`静态成员, 而不需要在类的外部`定义`静态成员时重复.

`静态数据成员`必须在类的`外部`进行`定义`和`初始化`.
每个`静态数据成员`都只能被定义一次, 这与每个`非内联成员函数`都只能被定义一次类似.
因此, `静态数据成员的定义`应当与所属类的`非内联成员函数的定义`放在同一个`源文件`中.

定义静态数据成员时, 可以访问该类的`私有`成员, 这与定义其他成员类似.

### 类内初始化静态数据成员
通常, 静态数据成员`不可以`在类的内部进行初始化, 但有两个例外:
- `可以`为静态 `const` 整型数据成员指定类内初始值.
- `必须`为静态 `constexpr` 数据成员指定类内初始值.

被指定的类内初始值必须是 `constexpr`, 这些在类内被初始化的静态数据成员本身也是 `constexpr`, 可以用于任何需要使用 `constexpr` 的地方.
例如:
```cpp
// account.h
class Account {
 public:
  // ...
 private:
  static constexpr int period = 30;  // period 是 constexpr
  double table[period];  // 数组长度必须是 constexpr
};
```
即使一个静态数据成员已经在类内被初始化, 通常也应在类外给出定义.
如果其初始值已经在类内给定, 则类外不得再给定初始值:
```cpp
// account.cpp
constexpr int Account::period;
```

### 不同于非静态成员的特殊用法
静态数据成员的类型可以是它自己所属的那个类:
```cpp
class Bar {
 private:
  static Bar mem1;  // 正确: 静态数据成员 可以是 不完整类型
  Bar *mem2;        // 正确: 指针成员 可以是 不完整类型
  Bar mem3;         // 错误: 非静态数据成员 必须是 完整类型
};
```
静态数据成员可以被用作默认实参:
```cpp
class Screen {
 public:
  Screen& clear(char = background);
 private:
  static const char background;
};
```

## 类型成员
一个类可以在其内部定义新的`类型`或`类型别名`作为自己的成员.
`类型成员`必须在使用前被定义, 因此通常将它们集中定义在类的头部.
`类型成员`与`数据成员`和`函数成员`遵循相同的访问控制规则:
```cpp
class Screen {
 public:
  typedef std::string::size_type Position;
 private:
  Position cursor = 0;
  Position height = 0, width = 0;
  std::string contents;
};
```
## 类作用域

## 非成员函数接口

## 构造函数

# 运算符重载

## 常用运算符

## 函数调用运算符

## 类型转换

# 拷贝控制

## 析构函数

## 拷贝构造函数

## 拷贝运算符

## 移动构造函数

## 移动运算符

# 继承

## 基类

## 派生类

## 类型转换与继承

## 访问控制与继承

# 动态绑定

## 虚函数

## 抽象基类

## 容器与继承


# 数据抽象

## 抽象数据类型
`类 (class)` 机制的主要目的是用来提供新的`抽象数据类型 (abstract data type)`.
这里的`抽象`体现在:
- 类的`用户`只需要了解并且只能够使用类的`接口 (interface)`:
  - 包括`公共方法成员`和`公共数据成员`的声明,
  - 有时还包括`非成员接口函数` (如二元运算符) 的声明;
  - 通常在`头文件 (.h)` 中以`源码`形式给出.
- 类的`设计者`负责提供类的`实现 (implementation)`:
  - 包括`私有方法成员`和`私有数据成员`,
  - 以及`成员方法和非成员接口函数的定义`;
  - 通常在`源文件 (.cpp)` 中以`源码`形式给出,
  - 也可以只提供编译生成的`目标文件` (包括`静态库`或`动态库`文件).

这样做的好处是:
- `用户代码`只依赖于`接口代码`, 而不依赖于`实现代码`:
  - 类的`设计者`不需要将算法细节暴露给类的`用户`, 有助于保护知识产权.
  - `用户代码`和`实现代码`可以同时独立地进行开发和测试.
  - `实现代码`发生变化时, 不需要重新`编译用户代码`, 而只需要重新`编译实现代码`, 并将新的目标文件`链接进用户程序`.
- 有助于减少不同类之间的依赖, 使得彼此的`实现代码`可以`独立变化`, 并且可以`缩短编译时间`.

## 访问控制
### 访问修饰符 (Access Specifiers)
一个类可以含有`零个或多个`访问修饰符, 每种访问修饰符出现的`次数和顺序不限`.
每个访问修饰符的`作用范围`始于自己, 终于下一个修饰符或类的末尾.

| 访问修饰符 | 从类的外部 | 从类的内部 |
| -------- | -------- | -------- |
| `public` | 可以直接访问 | 可以直接访问 |
| `private` | (除友元外) 无法直接访问 | 可以直接访问 |

### `class` 与 `struct` 的区别
对于访问控制, 二者的区别仅在于:

| 关键词  | 隐含的第 `0` 个访问修饰符 |
| ------ | ---------------------- |
| `struct` | `public` |
| `class` | `private` |

### 友元 (少用)
定义一个类时, 可以用 `friend` 将其他类或函数`声明`为它的`友元`, 从而允许这些友元访问其私有成员.
通常, 将`友元声明`集中放在类定义的头部或尾部.
`友元声明`不是`函数声明`, 必须在定义类之前, 声明这些将要被设为友元的函数.

友元机制破坏了类的封装, 因此要少用.

## 数据成员

## 函数成员
### 声明与定义
所有`成员函数`都必须在类的内部 (位于`头文件`中) 进行`声明`, 但其`定义`可以放在类的外部 (通常位于`源文件`中).

- `内联的`成员函数应当定义在`含有所属类定义的头文件`中.
  - 定义在类的`内部`的函数是 (隐式) 内联的.
  - 定义在类的`外部`的成员函数也可以是 (显式) 内联的: 只需要在函数的返回类型前面加上 `inline` 关键词.
- `非内联的`成员函数应当定义在`与含有所属类定义的头文件同名的源文件`中.

### `this` 指针
除`静态`成员函数外, 所有成员函数都是通过隐式指针 `this` 来访问调用它的那个对象的.
例如:
```cpp
SalesData total;
total.isbn()
```
相当于
```cpp
SalesData::isbn(&total)
```

### `const` 成员函数
默认情况下, `this` 为指向`非 const` 对象的指针, 这使得相应的成员函数无法被 `const` 对象调用.
如果要使 `this` 为指向 `const` 对象的指针: 只需要在函数形参列表后面紧跟 `const` 关键词.

## 静态 (`static`) 成员
静态成员由一个`类`的所有`对象`共享, 而不属于其中任何一个`对象`:
- 静态`数据`成员存储于所有`对象`的外部, 因此不计入`对象`的大小.
- 静态`函数`成员独立于所有`对象`, 因此形参列表中没有隐含 `this` 指针.

### 访问静态成员
在类的外部, 静态成员可以通过紧跟在`类名`后面的作用域运算符 `::` 来访问, 也可以 (像非静态成员一样) 通过对象或指向该对象的指针或引用来访问.
与非静态成员类似, 静态成员可以被所属类的成员函数直接访问, 而不需要借助于作用域运算符.

### 定义静态成员
关键词  `static` 仅用于在类的内部`声明`静态成员, 而不需要在类的外部`定义`静态成员时重复.

`静态数据成员`必须在类的`外部`进行`定义`和`初始化`.
每个`静态数据成员`都只能被定义一次, 这与每个`非内联成员函数`都只能被定义一次类似.
因此, `静态数据成员的定义`应当与所属类的`非内联成员函数的定义`放在同一个`源文件`中.

定义静态数据成员时, 可以访问该类的`私有`成员, 这与定义其他成员类似.

### 类内初始化静态数据成员
通常, 静态数据成员`不可以`在类的内部进行初始化, 但有两个例外:
- `可以`为静态 `const` 整型数据成员指定类内初始值.
- `必须`为静态 `constexpr` 数据成员指定类内初始值.

被指定的类内初始值必须是 `constexpr`, 这些在类内被初始化的静态数据成员本身也是 `constexpr`, 可以用于任何需要使用 `constexpr` 的地方.
例如:
```cpp
// account.h
class Account {
 public:
  // ...
 private:
  static constexpr int period = 30;  // period 是 constexpr
  double table[period];  // 数组长度必须是 constexpr
};
```
即使一个静态数据成员已经在类内被初始化, 通常也应在类外给出定义.
如果其初始值已经在类内给定, 则类外不得再给定初始值:
```cpp
// account.cpp
constexpr int Account::period;
```

### 不同于非静态成员的特殊用法
静态数据成员的类型可以是它自己所属的那个类:
```cpp
class Bar {
 private:
  static Bar mem1;  // 正确: 静态数据成员 可以是 不完整类型
  Bar *mem2;        // 正确: 指针成员 可以是 不完整类型
  Bar mem3;         // 错误: 非静态数据成员 必须是 完整类型
};
```
静态数据成员可以被用作默认实参:
```cpp
class Screen {
 public:
  Screen& clear(char = background);
 private:
  static const char background;
};
```

## 类型成员
一个类可以在其内部定义新的`类型`或`类型别名`作为自己的成员.
`类型成员`必须在使用前被定义, 因此通常将它们集中定义在类的头部.
`类型成员`与`数据成员`和`函数成员`遵循相同的访问控制规则:
```cpp
class Screen {
 public:
  typedef std::string::size_type Position;
 private:
  Position cursor = 0;
  Position height = 0, width = 0;
  std::string contents;
};
```
## 类作用域

## 非成员函数接口

## 构造函数 (Constructor)
构造函数是一种`以类名作为函数名`的特殊成员函数, 用于构造该类的对象.
在构造过程中, 需要修改数据成员的值, 因此构造函数不可以被声明为 `const`.

与一般的函数不同, 构造函数`没有返回类型`.

### 默认构造函数
`不接受实参`的构造函数称为`默认 (default)` 构造函数.
默认构造函数可以是`形参列表为空`的构造函数, 也可以是`所有形参都有默认实参值`的构造函数.

#### 合成的默认构造函数
如果没有`显式地`定义任何构造函数, 那么编译器会`隐式地`定义一个`合成的 (synthesized)` 默认构造函数.
C++11 允许程序员显式地使用编译器合成的版本, 只需要在定义时在 (空) 形参列表后紧跟 `= default;` 即可.

### 初始化列表
```cpp
class Point {
  double _x;
  double _y;
};
```
`初始化列表`位于 `:` 与 `{` 之间, 用于对数据成员进行`值初始化`:
```cpp
// 推荐: 在 初始化列表 中进行 值初始化
Point::Point(const double& x, const double& y) : _x(x), _y(y) { }
```
如果某个数据成员没有在`初始化列表`中被初始化, 则会被`默认初始化`, 然后才会被函数体内的赋值语句修改:
```
// 语义相同, 但 默认初始化 过程浪费了计算资源
Point::Point(const double& x, const double& y) {
  _x = x;
  _y = y;
}
```

如果某个成员的值在初始化之后无法被修改, 则必须在`初始化列表`中对其进行初始化:
- 该成员是 `const`
- 该成员是`引用`类型
- 该成员无法被`默认初始化` (即: 没有默认构造函数)

#### 成员构造的顺序
成员构造的顺序不是它们出现在`初始化列表`中的顺序, 而是它们出现在`类的定义`中的顺序.

#### 委托构造函数
一个构造函数只需要在`初始化列表`中`调用`另一个构造函数, 就可以将构造任务`委托`给另一个构造函数, :
```cpp
class Point {
 public:
  Point(const double& x, const double& y) : _x(x), _y(y) { }
  Point() : Point(0.0, 0.0) { }
 private:
  double _x;
  double _y;
};
```

### 显式 (`explicit`) 构造函数
默认情况下, 只需要传入`一个实参`的构造函数`隐式地`定义了一种由`形参类型`到该`类类型`的转换.
编译器只会进行一次隐式类型转换.

如果要禁止这种隐式类型转换, 只需要在构造函数的声明`前`, 用关键词 `explicit` 进行修饰.
例如:
```cpp
namespace std{
template <
  class T, 
  class Allocator = std::allocator<T>
> class vector {
 public:
  explicit vector(std::size_type count);  // 禁止用于隐式类型转换
  // ...
};
}
```

# 运算符重载

## 常用运算符

## 函数调用运算符

## 类型转换

# 拷贝控制

## 析构 (Destroy)
### 析构函数 (Destructor)
析构函数是一种`以 ~ 为前缀的类名作为函数名`的特殊成员函数, 用于析构 (销毁) 该类的对象.
析构函数`没有返回类型`, 并且`形参列表为空`.
```cpp
class Foo {
 public:
  ~Foo();  // destructor
  // ...
};
```

### 成员析构的顺序
一个对象被析构时, 先执行其所属类型的析构函数体中的语句, 再隐式地析构其 (非静态) 数据成员.
数据成员被析构的顺序与它们被构造的顺序`相反`, 即: 与它们在类的定义中出现的顺序相反.

### 合成的析构函数
如果析构函数没有被`显式地声明`, 那么编译器会`隐式地定义`一个默认的版本, 称为`合成的析构函数`.
C++11 允许程序员显式地使用编译器合成的版本, 只需要在定义时在 (空) 形参列表后紧跟 `= default;` 即可.

合成的析构函数, 只会`逐个析构`数据成员 --- 这意味着: 不会对`裸指针`成员调用 `delete`.

## 拷贝 (Copy)
### 拷贝构造函数 (Copy Constructor)
拷贝构造函数是一类特殊的构造函数:
- `第一个形参`为`指向该类型对象的引用`, 并且几乎总是`指向常量的引用`.
- `其余形参`均有`默认实参值`.
```cpp
class Foo {
 public:
  Foo(const Foo&);
  // ...
};
```
在许多场合, 拷贝构造函数会被`隐式地`调用, 因此通常不应设为 `explicit`.

### 拷贝赋值运算符 (Copy Assignment Operator)
拷贝赋值运算符是对成员函数 `operator=` 的重载, 函数签名几乎总是如下形式:
- 唯一的 (显式) 形参的类型为: 指向`常值`对象的引用.
- 返回类型为: 指向`非常值`对象的引用.
```cpp
class Foo {
 public:
  Foo& operator=(const Foo&);
  // ...
};
```

### (C++11) 删除的拷贝操作
有些类型的对象不应支持拷贝操作 (例如 `std::iostream`).
为了实现该语义, (在 C++11 下) 只需在声明`拷贝构造函数`和`拷贝赋值运算符`时, 将它们标注为`删除的 (deleted)`:
```cpp
class Foo {
 public:
  Foo(const Foo&) = delete;
  Foo& operator=(const Foo&) = delete;
  // ...
};
```

### 合成的拷贝操作
合成的拷贝操作 (`拷贝构造函数`和`拷贝赋值运算符`) 会`逐个拷贝`数据成员 --- 这意味着: 只会对`裸指针`进行`浅拷贝`.

如果含有数组成员, 则合成的拷贝操作会`逐个拷贝成员数组的每一个元素`.

如果一个类含有`无法拷贝的`数据成员, 则这个类本身也应当是`无法拷贝的`, 因此合成的拷贝操作将是`删除的`.

## 移动 (Move)

### 右值
类型名后紧跟 `&&` 表示定义一个指向该类型对象的`右值引用`:
- `右值引用` (通常) 只能绑定到`即将被析构的对象`上.
- 定义在 `<utility>` 中的库函数 `std::move` 可以将`左值表达式`变为`右值表达式`.

通常, `左值表达式`代表对象的`身份 (identity)`, 而`右值表达式`代表对象的`值 (value)`.
`右值引用`作为一个表达式是一个`左值表达式`:
```cpp
int i = 42;
int& r = i;              // 正确: 将 左值引用 绑定到 左值表达式
int& r2 = i * 42;        // 错误: 普通左值引用 无法绑定到 右值表达式
const int& r3 = i * 42;  // 正确: 指向常量的左值引用 可以绑定到 右值表达式
int&& rr = i;                // 错误: 右值引用 无法直接绑定到 左值表达式
int&& rr2 = i * 42;          // 正确: 将 右值引用 绑定到 右值表达式
int&& rr3 = std::move(rr2);  // 正确: std::move 将 左值表达式 变为 右值表达式
```

### 移动构造函数 (Move Constructor)

移动构造函数是一类特殊的构造函数:
- `第一个形参`为`指向该类型对象的右值引用`.
- `其余形参`均有`默认实参值`.
- 必须确保析构`移动源 (moved-from) 对象`是安全的.
```cpp
template <typename T>
class Vector {
 public:
  Vector(Vector&& rhs) noexcept  // 不抛出异常
      // 接管 移动源对象 的数据成员:
      : _head(rhs._head), _free(rhs._free), _tail(rhs._tail) {
    rhs._head = rhs._free = rhs._tail = nullptr;  // 确保 析构 rhs 是安全的
  }
  // ...
 private:
  T* _head;  // 指向 首元
  T* _free;  // 指向 第一个自由元
  T* _tail;  // 指向 过尾元
};
```

### 移动赋值运算符 (Move Assignment Operator)
```cpp
template <typename T>
class Vector {
 public:
  Vector& operator=(Vector&& rhs) noexcept {  // 不抛出异常
    if (this == &rhs) {  // 自己给自己复制, 不做任何事
      ;
    } else {
      free();  // 析构 被赋值对象 中的元素, 释放内存
      // 接管 移动源对象 的数据成员:
      _head = rhs._head;
      _free = rhs._free;
      _tail = rhs._tail;
      rhs._head = rhs._free = rhs._tail = nullptr;  // 确保 析构 rhs 是安全的
    }
    return *this;  // 返回 左值引用
  }
 private:
  void free();  // 析构元素, 释放内存
  T* _head;  // 指向 首元
  T* _free;  // 指向 第一个自由元
  T* _tail;  // 指向 过尾元
```

### 异常与容器
容器类型 (例如 `std::vector<T>`) 在`重新分配 (reallocation)` 的过程中, 需要将所存储的元素`逐个搬运`到新分配的内存空间里.
对于类类型 (class type) `T`, 这个搬运动作是利用 `T` 的`拷贝构造函数`来完成的.
如果 `T` 的`移动构造函数`被标注为`不会抛出异常`, 则容器会利用 `T` 的`移动构造函数`来搬运元素.

因此, `移动构造函数`和`移动赋值运算符`应当用不会抛出异常的方法来实现, 并且在`声明`和`定义`时都用 `noexcept` 进行标注.

# 继承与动态绑定

## 基类与派生类

| 名称 | 同义词 | 任务 |
| ---- | ---- | ---- |
| 基类 (base class) | 父类 (superclass) | 定义自己和派生类`共有的 (common)` 成员 |
| 派生类 (derived class) | 子类 (subclass) | 定义自己`特有的 (specific)` 成员 |

### 声明与定义
一个类只有被`定义`过 (而不仅仅被`声明`过), 才能被用作基类
```cpp
class Base;
class Derived : public Base { ... };  // 错误: 用作基类的 Quote 还没有被定义
```

派生列表只出现在派生类的`定义`中, 而不出现在派生类的`声明`中:
```cpp
class Derived : public Base;  // 错误: 派生列表 只出现在 派生类定义 中
class Derived;                // 正确: 派生列表 不出现在 派生类声明 中
```

### 构造函数
`派生类构造函数`必须用`基类构造函数`来初始化`派生类对象的基类部分`:
```cpp
class Quote {
  std::string _title;
  double price;
 public:
  Quote(const std::string& title, double price)
      : _title(title), _price(price) { }
  // ...
};
class BulkQuote : public Quote {
  std::size_t _amount;
  double _discount;
 public:
  BulkQuote(const std::string& title, double price, 
            std::size_t amount, double discount)
      : Quote(title, price),  // 用 基类构造函数 来初始化 派生类对象的基类部分
        _amount(amount), _discount(discount) { }
  // ...
};
```

### 静态数据成员
基类中定义的静态数据成员被继承体系中的所有派生类共享.

### (C++11) 阻止继承
类名后面紧跟 `final` 关键词, 表示该类不可以被用作基类:
```cpp
class NoDerived final { /* ... */ };
```

## 继承级别与访问控制


### `class` 与 `struct` 的区别
对于继承级别, 二者的区别仅在于:

| 关键词  | 默认的继承级别 |
| ------ | ---------------------- |
| `struct` | `public` |
| `class` | `private` |

为提高代码可读性, 应当`显式`写出继承级别.

## 自动类型转换





## 虚函数与动态绑定


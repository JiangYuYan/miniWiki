# 模板函数
`T` 的实际类型将根据 `compare` 的`静态`调用方式在`编译期`决定:

```cpp
template <typename T>  // 模板参数列表
int compare(const T& v1, const T& v2) {
  if (v1 < v2) return -1;
  if (v2 < v1) return 1;
  return 0;
}
```

`inline`, `constexpr` 等修饰符应当位于`模板参数列表`与`返回值类型`之间:
```cpp
template <typename T>
inline T min(const T&, const T&);
```

编写模板函数应当
- 尽量减少对参数类型的要求.
- 用`指向常量的引用`作为函数参数类型,  这样可以使得代码也适用于不可拷贝的类型.
- 只用 `<` 进行比较操作, 这样用于实例化模板的类型实参只需要支持 `<` 而不必支持 `>`.

## 函数重载
编译器首先根据`类型转换次数`对所有待选 (模板和非模板) 函数进行排序:
- 如果正好有一个函数的匹配程度比其他函数更高, 则它将被选中.
- 如果匹配程度最高的函数有多个, 则
  - 如果其中只有一个`非模板`, 则它将被选中.
  - 如果其中没有非模板, 且有一个`模板`比其他的更加`特殊化 (specialized)`, 则它将被选中.
  - 否则, 该调用有歧义, 编译时会报错.

# 模板类

# 成员模板

# 模板参数

# 类型参数推导

# 实例化

# 特化

# 可变参数模板


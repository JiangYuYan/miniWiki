---
title: 异常控制流
---

- 【控制转移 (control transfer)】“程序计数器 (program counter)”的值由一条指令的地址变为下一条指令的地址的过程。
- 【控制流 (control flow)】由控制转移构成的序列。
  - 【常规控制流】除依次执行相邻指令的光滑控制流外，只含有由“跳转”“调用”“返回”等指令引起的控制流突变。
  - 【异常控制流 (exceptional control flow, ECF)】含有由不能被程序内部变量捕捉的（甚至与程序执行无关的）系统状态变化引起的控制流突变。

理解 ECF 有助于
- 理解重要系统概念（读写、进程、虚拟内存）
- 理解应用程序与操作系统的交互
- 编写应用程序（shell、网络服务器）
- 理解“并发 (concurrency)”
- 理解“软件异常 (software exceptions)”的工作原理

# 1. 异常

- 【异常 (exception)】由某个“事件”引起的控制流突变。
- 【事件 (exception)】处理器状态的某种显著的变化。
  - 可能由当前指令有关，如：访存发生“页面故障 (page fault)”。
  - 也可能与当前指令无关，如：读写请求完成。

当处理器检测到某个事件发生时，它会将 PC 设为存储在“异常表 (exception table)”中的某个地址。
该地址指向用于响应该事件的某个系统子程序，即“异常处理者 (exception handler)”。
此机制被称为“间接过程调用 (indirect procedure call)”。

## 异常处理

- 【异常编号 (exception number)】
  - 用于标识异常的非负整数
  - 其中一些由处理器设计者定义，如：浮点错误（除以零）、页面故障、非法访存。
  - 其余由操作系统内核设计者定义，如：系统调用、读写信号。
- 【异常表 (exception table)】
  - 在系统启动时，由操作系统分配并初始化，表头地址存于特定寄存器中。
  - 其中第 $k$ 项为“事件 $k$”的异常处理者（的地址）。

|          |       异常（间接过程调用）       |  函数（普通过程调用）  |
| :------: | :------------------------------: | :--------------------: |
| 返回地址 | 可能为当前指令或下一条指令的地址 |  总是下一条指令的地址  |
| 压栈内容 |      可能包括其他处理器状态      | 调用者负责保存的寄存器 |
| 栈所有者 |             系统内核             |        用户程序        |
| 执行模式 |       内核模式（访问无限）       |  用户模式（访问受限）  |

## 异常分类

- 【异步 (asynchronous)】并非由正在执行的指令引起
  - 【中断 (interrupt)】处理器收到读写设备发出的信号
- 【同步 (synchronous)】由正在执行的指令引起
  - 【陷阱 (trap)】应用程序调用系统子程序
  - 【故障 (fault)】发生可以被修复的错误
  - 【终止 (abort)】发生不可被修复的错误

### 中断

1. 执行指令 $I_\text{curr}$ 时，处理器收到读写设备（网络适配器、硬盘控制器、计时器）发来的信号。
2. 待 $I_\text{curr}$ 执行完后，控制权转移到“中断处理者 (interrupt handler)”，并运行之。
4. 返回到紧随 $I_\text{curr}$ 的下一条指令 $I_\text{next}$。

### 陷阱

1. 应用程序通过 `syscall` 指令调用系统子程序。
2. 控制权转移到“陷阱处理者 (trap handler)”，并运行之。
3. 返回到紧随 `syscall` 的下一条指令 $I_\text{next}$。

### 故障

1. 执行指令 $I_\text{curr}$ 时，发生“故障 (fault)”。
2. 控制权转移到“故障处理者 (fault handler)”，并运行之。
3. 若成功排除故障，则返回到引起故障的 $I_\text{curr}$ 并重新执行；否则终止该程序。

### 终止

1. 执行指令 $I_\text{curr}$ 时，发生不可修复的“致命错误 (fatal error)”。
2. 控制权转移到“终止处理者 (abort handler)”，并运行之。
3. 返回到 `abort` 以终止当前程序的执行。

## Linux/x86-64 系统的异常

### 故障及终止

|  编号   |        描述        |    分类    |
| :-----: | :----------------: | :--------: |
|    0    |      除法溢出      |    故障    |
|   13    |      非法访存      |    故障    |
|   14    |      页面故障      |    故障    |
|   18    |      硬件错误      |    终止    |
| 32～255 | 操作系统定义的异常 | 中断、陷阱 |

### 系统调用

- 【系统级函数 (system-level functions)】形如函数的系统调用（或其封装）。
- 【陷阱指令 (trap instruction)】名为 `syscall` 的 x86-64 指令。
  - 寄存器 `rax` 存储系统调用编号。
  - 寄存器 `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` 依次存储第一到六个实参。

| 编号 |   名称   |         描述          |
| :--: | :------: | :-------------------: |
|  0   |  `read`  |                       |
|  1   | `write`  |                       |
|  2   |  `open`  |                       |
|  3   | `close`  |                       |
|  4   |  `stat`  |     获取文件信息      |
|  9   |  `mmap`  | 将内存页面映射到文件  |
|  12  |  `brk`   |       重设堆顶        |
|  32  |  `dup2`  |    复制文件描述符     |
|  33  | `pause`  |  暂停进程，等待信号   |
|  37  | `alarm`  | 安排 alarm 信号的发送 |
|  39  | `getpid` |                       |
|  57  |  `fork`  |                       |
|  59  | `execve` |                       |
|  60  | `_exit`  |       终止进程        |
|  61  | `wait4`  |   等待某个进程终止    |
|  62  |  `kill`  |  向某个进程发送信号   |

# 2. 进程

- 【进程 (process)】执行中的程序实例。
- 【上下文 (context)】程序正确运行所需的状态，包括
  - 内存中的代码及数据
  - 运行期栈
  - 通用寄存器的内容
  - 程序计数器
  - 环境变量
  - 已打开文件的描述符

## 逻辑控制流

“逻辑控制流 (logical control flow)”，简称“逻辑流”，是指由程序计数器的值构成的序列。

该机制使得当前程序看上去像是独占了处理器。

## 并发流

【并发流 (concurrent flow)】运行时间有重叠的多个逻辑流。
- 【多任务 (multitasking)】多个进程轮流执行片段，又名“时间分割 (time slicing)”。
- 【并行流 (parallel flow)】运行在多个核心或计算机上的并发流。

## 私有地址空间

- 【地址空间 (address space)】由 $0$ 到 $2^n-1$ 共 $2^n$ 个地址构成的集合
- 【私有 (private)】每个进程只能读写自己的地址空间
- 不同进程的私有地址空间，有相同的组织（结构）。

## 用户与内核模式

- 【模式位 (mode bit)】存于特定寄存器中，表示当前进程的权限。
- 【内核模式 (kernel mode)】模式位非空，可以执行任何指令、访问任何地址。
- 【用户模式 (user mode)】模式位为空，只能执行部分指令、访问部分地址。

应用程序的进程，启动时处于用户模式；要变为内核模式，只能通过异常。

Linux 允许用户模式的进程通过 `/proc` 文件系统访问内核数据结构的内容，如

- `/proc/cpuinfo` 表示处理器信息
- `/proc/PID/maps` 表示内存映射

## 上下文切换

【抢占 (preempt)】

【调度 (scheduling)】操作系统内核决定是否暂存当前进程、恢复之前被抢占的进程。

【上下文切换 (context switch)】

1. 保存当前进程的上下文
2. 恢复之前被抢占的进程的上下文
3. 移交控制权

可能发生于

- 需要较长时间才能返回的系统调用之后
  - `read`
  - `sleep`
- 周期性的计时器中断之后
- 中断处理之后

# 3. 系统调用错误处理

# 4. 进程控制

# 5. 信号

# 6. 非局部跳转

# 7. 进程管理工具
